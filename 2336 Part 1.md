# Java OOP, Recursion, Generics Reference

---

## Table of Contents
- [Java Overview](#java-overview)
- [Programming Fundamentals](#programming-fundamentals)
- [Recursion](#recursion)
- [Encapsulation](#encapsulation)
- [Polymorphism](#polymorphism)
- [Generics](#generics)
- [Arrays](#arrays)
- [Inheritance and Interfaces](#inheritance-and-interfaces)
- [Core Notes: Methods, Classes, Objects](#core-notes-methods-classes-objects)

---

# Java Overview

## What and Why Java?

- **Java** is a general purpose, object-oriented, platform-independent programming language, particularly prominent for Internet, server, desktop, and mobile applications.
- Notable features: simple, object-oriented, distributed, interpreted, robust, secure, architecture-neutral, portable, high performance, multithreaded, and dynamic.
- Java programs are written once and run anywhere (WORA) using the Java Virtual Machine (JVM).

---

# Programming Fundamentals

## Data Types, Variables, and Operators

- Java supports several primitive types: `int`, `double`, `float`, `char`, `boolean`, along with reference types such as `String` and user-defined classes.
- Variable declarations and initialization:
    ```java
    int x = 1;
    double radius = 2.5;
    final double PI = 3.14159;
    ```
- Operators: arithmetic (`+`, `-`, `*`, `/`, `%`), assignment, relational, logical (`&&`, `||`, `!`), and increment/decrement (`++`, `--`).

## Control Flow

- Conditional: `if`, `else if`, `else`, `switch`.
- Loops: `while`, `do-while`, `for` (including enhanced for-each).
    ```java
    for (int i = 0; i < 10; i++) { ... }
    ```

## Input/Output

- Using `Scanner` for input and `System.out` for output.
    ```java
    Scanner input = new Scanner(System.in);
    int value = input.nextInt();
    ```

---

# Recursion

## Concepts and Motivation

Recursion means defining a solution in terms of smaller instances of the same problem. It needs:
- **Base case**: stops recursion.
- **Recursive case**: reduces the problem, calling itself.

### Example: Factorial
```java
public class Factorial {
    public static int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    public static void main(String[] args) {
        int num = 5;
        System.out.println(factorial(num));
    }
}
```
- `factorial(0)` returns 1. `factorial(n)` returns \( n \times factorial(n-1) \).

### Example: Fibonacci
```java
public class Fibonacci {
    public static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n-1) + fibonacci(n-2);
    }
    public static void main(String[] args) {
        int n = 8;
        System.out.println(fibonacci(n));
    }
}
```

### Tail vs Non-tail Recursion

- **Non-tail**: recursive call is not the last statement.
    ```java
    int sum(int n) {
        if (n == 0) return 0;
        return n + sum(n-1);
    }
    ```
- **Tail**: recursive call is the last statement; passes current computation in an argument.
    ```java
    int tailSum(int n, int acc) {
        if (n == 0) return acc;
        return tailSum(n - 1, acc + n);
    }
    ```

## Recursive Helper Methods

Helps avoid repeated string slicing or additional operations.
```java
public static boolean isPalindrome(String s) {
    return isPalindrome(s, 0, s.length() - 1);
}
private static boolean isPalindrome(String s, int low, int high) {
    if (high <= low) return true;
    if (s.charAt(low) != s.charAt(high)) return false;
    return isPalindrome(s, low + 1, high - 1);
}
```

## Practical Applications
- Directory/file search
- GCD/euclidean algorithm
- Sorting algorithms (e.g., recursive selection sort)
- Tower of Hanoi

---

# Encapsulation

## Concept

Encapsulation bundles data (attributes) and operations (methods) into a class while hiding the data via access modifiers (private variables, public getters/setters).

## Example: Getters and Setters

```java
public class Employee {
    private String name;
    private float salary;

    public Employee(String name, float salary) {
        this.name = name;
        this.salary = salary;
    }
    public String getName() { return name; }
    public float getSalary() { return salary; }
    public void setName(String name) { this.name = name; }
    public void setSalary(float salary) { this.salary = salary; }
}
```

## Access Modifiers Table

| Category    | Public | Private |
| ----------- |:------:|:-------:|
| Constructor |   X    |         |
| Methods     |   X    |    X    |
| Attributes  |        |    X    |

## Black Box Principle

A user interacts only through a public interface; internal implementation is hidden.

---

# Polymorphism

## What is Polymorphism?

Allows a single name/interface to represent different types (forms). Manifested as:
- Method overloading: same method name, different signatures.
- Method overriding: subclass redefines superclass method.

## Operator Overloading Example
```java
System.out.println(5 + 10);    // Addition
System.out.println("5" + "10"); // Concatenation
```

## Method Overriding Example
```java
class Alpha {
    public void show() { System.out.println("Alpha"); }
}
class Bravo extends Alpha {
    public void show() { System.out.println("Bravo"); }
}
```

## Method Overloading Example
```java
class TestClass {
    public int sum(int a, int b, int c) { return a + b + c; }
    public int sum(int a, int b) { return a + b; }
}
```

## Abstract Classes and Methods

Use abstract classes when methods must be redefined in child classes.
```java
abstract class Person {
    public abstract String greeting();
}
class Engineer extends Person {
    public String greeting() { return "Hello from Engineer"; }
}
```

---

# Generics

## Motivation and Syntax

Generics provide compile-time safety for classes or methods operating on various types.

```java
class Repeater<T> {
    T value;
    public Repeater(T value) { this.value = value; }
    public void repeat() { System.out.println(value); }
}
```

## Generic Methods

```java
public static <T> void echo(T value, int n) {
    for(int i=0;i<n;i++) System.out.print(value + " ");
    System.out.println();
}
```

## Multiple Type Parameters

```java
class Pair<T, U> {
    T first;
    U second;
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}
```

## Bounded Generics

Restrict a type parameter to a subclass (e.g., `T extends Number`).

## Wildcards

- `List<? extends Number>`: List of some unknown subclass of `Number`.
- `List<? super Integer>`: List of Integer or superclass.

## PECS (Producer Extends, Consumer Super)

- Use `extends` for a producer, `super` for a consumer.

---

# Arrays

## Single-Dimensional Arrays

```java
int[] arr = new int;
double[] list = {1.1, 2.2, 3.3};
```
- `arr.length` gives size
- Default values: 0 for numbers, `false` for booleans.

## Multidimensional Arrays

```java
int[][] matrix = new int; // 3 rows, 4 columns[1]
```

## Enhanced For Loop

```java
for (double v : list) System.out.println(v);
```

## Common Algorithms

- **Linear Search**: `for (int i=0; i<list.length; i++)`
- **Binary Search** (sorted arrays): `Arrays.binarySearch(myArray, key);`
- **Selection Sort, Copying, Shuffling**

---

# Inheritance and Interfaces

## Inheritance

- Subclass (`extends Superclass`) inherits fields and methods.
- `super` keyword calls superclass constructor or method.

### Example
```java
class Animal {
    public void eat() { System.out.println("Eating"); }
}
class Dog extends Animal {
    public void bark() { System.out.println("Bark"); }
}
```

## Interfaces

- Define method signatures, not implementation.
- `class MyClass implements MyInterface`

### Example
```java
public interface Edible {
    String howToEat();
}
class Fruit implements Edible {
    public String howToEat() { return "Slice and eat."; }
}
```

## Abstract Classes vs. Interfaces

- Abstract classes can have fields, implemented methods.
- Interfaces cannot have fields (except public static final constants), all methods are abstract by default.

---

# Core Notes: Methods, Classes, Objects

## Classes and Objects

- A class defines a template; objects are instances created using constructors.
- Instance variables belong to an object; static variables are shared.

## Constructors

- Special methods to initialize objects. If no constructor is defined, the default constructor is used.

## Static Members

- Shared among all instances of a class. Declared with `static`.

## The `this` Keyword

- Refers to the current object. Used to resolve naming conflicts and call other constructors.

## Method Overloading and Overriding

- **Overloading:** Same method name, different parameters.
- **Overriding:** Subclass provides new implementation for a method declared in superclass.

## Access Control

- `private`: Only within class.
- `default` (no modifier): Package-private.
- `protected`: Package and subclass.
- `public`: Everywhere.

## Arrays of Objects

```java
Circle[] circles = new Circle;
```
Objects must still be constructed for each array element.

---

# Additional Practice and Key Tips

- Favor meaningful variable and class names.
- Use proper indentation, code comments, and follow Java conventions for readability and maintainability.
- Avoid logic errors (e.g., misplaced semicolons after `if`/`for`).
- Prefer loops when number of iterations is known, recursion for structurally-defined problems.
- Summarize areas for objects/classes and use generic collections (`ArrayList<T>`) for dynamic grouping.
- Use wrapper classes as needed (e.g., `Integer`, `Double`), especially with generics.

---

```
