
# Java OOP, Recursion, Generics Reference

---

## Table of Contents
- [Recursion](#recursion)
- [Encapsulation](#encapsulation)
- [Polymorphism](#polymorphism)
- [Generics](#generics)

---

# Recursion

## Concepts and Motivation
Recursion is when a function calls itself to break a problem into smaller pieces. It is useful for problems that can be defined in terms of smaller subproblems.

### Key Ideas
- **Base case:** Stops recursion, preventing infinite calls.
- **Recursive case:** The function calls itself with reduced subproblem.

---

## Factorial with Recursion
```
public static int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

---

## Fibonacci with Recursion
```
public static int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

---

## Tail Recursion and Non-tail Recursion
- **Non-tail recursion:** Recursive call is not the last action in the function.
- **Tail recursion:** Recursive call is the last thing; often uses a helper to carry the result.

---

## Helper/Overloaded Method Example
```
public static int sumList(int[] arr) {
    return sumListHelper(arr, 0);
}

private static int sumListHelper(int[] arr, int idx) {
    if (idx == arr.length) return 0;
    return arr[idx] + sumListHelper(arr, idx + 1);
}
```

---

# Encapsulation

## What is Encapsulation?

Encapsulation groups related data and methods and restricts direct access to some of an object's components. This provides control over the data by using access modifiers: `public` and `private`.

---

## Example: Using Getters and Setters
```
public class Employee {
    private String name;
    private float salary;

    public Employee(String name, float salary) {
        this.name = name;
        this.salary = salary;
    }
    public String getName() { return name; }
    public float getSalary() { return salary; }
    public void setName(String name) { this.name = name; }
    public void setSalary(float salary) { this.salary = salary; }
    public void displayDetails() {
        System.out.println("Employee: " + name);
        System.out.println("Salary: " + salary);
    }
}
```
---

## Access Modifiers

| Category    | Public | Private |
| ----------- |:------:|:-------:|
| Constructor |   X    |         |
| Methods     |   X    |    X    |
| Attributes  |        |    X    |

---

## Class Example
```
class ExampleClass {
    private int num1;
    private int num2;

    public ExampleClass(int n1, int n2) {
        num1 = n1;
        num2 = n2;
    }
    public String describe() {
        return ("My numbers are: " + num1 + " and " + num2);
    }
    public int sum() { return num1 + num2; }
}
```
Instantiation:
```
ExampleClass myExample = new ExampleClass(5, 7);
System.out.println(myExample.describe());
System.out.println(myExample.sum());
```

---

## Example: Words Class with Private Helper
```
class Words {
    private String[] words;
    private int[] count;
    public Words(String[] listOfWords) {
        words = listOfWords;
        count = new int[words.length];
    }
    public void countVowels() {
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            for (int j = 0; j < word.length(); j++) {
                if (isVowel(word.charAt(j))) {
                    count[i]++;
                }
            }
        }
    }
    private boolean isVowel(char letter) {
        char[] vowels = {'a', 'e', 'i', 'o', 'u'};
        for (char v : vowels) if (letter == v) return true;
        return false;
    }
    public void printVowelCount() {
        for (int num : count) System.out.print(num + " ");
        System.out.println();
    }
}
```

---

## Black Box Principle

A "black box" system hides internal details from the user, allowing interaction through public methods only.

---

# Polymorphism

## What is Polymorphism?

Polymorphism allows a single interface (like a method name) to have different forms (behaviors). Common in operators/overloading and inheritance.


## Operator Overloading Example
```
int a = 5;
int b = 10;
System.out.println(a + b);

String c = "5";
String d = "10";
System.out.println(c + d);
```
- The `+` operator works for both numbers (addition) and strings (concatenation).


## Method Overriding Example
```
class Alpha {
    public void show() { System.out.println("I am from class Alpha"); }
}
class Bravo extends Alpha {
    public void show() { System.out.println("I am from class Bravo"); }
}
```
If you call `show()` on a `Bravo` object, Java uses the subclass implementation.


## Method Overloading Example
```
class TestClass {
    public int sum(int n1, int n2, int n3) { return n1 + n2 + n3; }
    public int sum(int n1, int n2) { return n1 + n2; }
}
TestClass tc = new TestClass();
System.out.println(tc.sum(1, 2, 3)); // 6
System.out.println(tc.sum(1, 2));    // 3
```

---

## Abstract Classes and Methods

Abstract classes cannot be directly instantiated; they contain abstract methods that must be implemented by derived classes.

```
abstract class Person {
    private String name;
    public String getName() { return name; }
    public void setName(String newName) { name = newName; }
    public abstract String greeting();
}
class Engineer extends Person {
    private String specialty;
    public Engineer(String n, String s) { setName(n); specialty = s; }
    public String greeting() {
        return "Hello, my name is " + getName() + " and I am a(n) " + specialty + ".";
    }
}
```

---

# Generics

## Motivation and Syntax

Generics allow a class or method to operate on objects of various types while providing compile-time safety.

```
class Repeater<T> {
    T repeatValue;
    public Repeater(T repeatValue) { this.repeatValue = repeatValue; }
    public void repeat() { System.out.println(this.repeatValue); }
}
Repeater<Integer> r1 = new Repeater<>(7);
```

---

## Generic Methods

```
private static <T> void echo(T value, int n) {
    for (int i = 0; i < n; i++) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```
Usage in main:
```
echo(1, 3);
echo("dog", 7);
```

---

## Multiple Type Parameters

```
class Repeater<T,V> {
    T repeatValue1;
    V repeatValue2;
    public Repeater(T v1, V v2){
        repeatValue1 = v1;
        repeatValue2 = v2;
    }
    public void repeat(){
        System.out.println(repeatValue1);
        System.out.println(repeatValue2);
    }
}
Repeater<Boolean, String> r1 = new Repeater<>(false, "Dog");
r1.repeat();
```

---

## Bounded Generics

Restrict type parameters so only types matching upper or lower bounds may be used.
```
class Wrapper<T extends Application> { ... }
```
- Now only Application objects or subclasses can be wrapped.

---

## Wildcards in Generics

- `? extends Number` — any subclass of Number
- `? super Integer` — Integer or its superclass

```
public static int total(List<? extends Number> numbers) {
    int sum = 0;
    for (Number number : numbers) sum += number.intValue();
    return sum;
}
public static void appendNumber(List<? super Integer> numbers){
    numbers.add(42);
}
```

---

## Collections, Producer-Consumer (PECS)

- **Producer:** use `extends`
- **Consumer:** use `super`

---

## Example: Generic Summing

```
public static <S extends Number> double sum(List<S> list) {
    double sum = 0;
    for (S elem : list) {
        sum += elem.doubleValue();
    }
    return sum;
}
```
